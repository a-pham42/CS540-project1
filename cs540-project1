import './App.css';
import React, { useState, useEffect, useMemo } from 'react';
import { Bar } from 'react-chartjs-2';  // import chart.js
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
} from 'chart.js';

ChartJS.register( // register chart.js components
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
);

// allow user to set the number of processes (1-9)
function NumberOfProcesses() {
  const [numberInput, setNumberInput] = useState(''); // initial value is empty

  // handle changes in the input field
  function handleInputChange(event) {
    const value = parseInt(event.target.value, 10); // convert user input into an integer
    if (!isNaN(value) && value >= 1 && value <= 9) { // only update state of numberInput if user entered a valid input
      setNumberInput(value);
    } else if (event.target.value === '') { // allow empty input if user clears input
      setNumberInput('');
    }
  }

  return (
    <form>
      <input
        type="text"
        placeholder="Enter number..."
        value={numberInput}
        onChange={handleInputChange}
      />
      <RandomProcessGenerator numOfProcesses={numberInput} />
    </form>
  );
}

// generate random processes & run the scheduling algorithms
function RandomProcessGenerator({ numOfProcesses }) {
  const [randomTimes, setRandomTimes] = useState([]); // initial values are empty

  // function that generates a list of random times from 100ms to 1000ms
  function generateRandomTime(){

    const times = []; // initiallize list "times"
    for(let i = 0; i < numOfProcesses; i++){
      const time = Math.floor(Math.random() * (1000 - 100 + 1)) + 100; // generate random number from 100 to 1000
      times.push(time);
    }
    setRandomTimes(times); // update state of randomTimes
  }

  // only generate times if numOfProcesses > 0
  useEffect(() => {
    if (numOfProcesses > 0) {
      generateRandomTime(); // generate random times
    }
  }, [numOfProcesses]); // re-run whenever numOfProcesses changes

  const namesList = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
  const tableData = useMemo(() => {
    return randomTimes.map((time, index) => ({
      name: namesList[index],
      length: time,
    }));
  }, [randomTimes]);

  return (
    <div>
      <ProcessTable processData={tableData} />
      <br />
      <FirstInFirstOut processData={tableData} />
      <br />
      <ShortestJobFirst processData={tableData} />
      <br />
      <ShortestTimeToCompletion processData={tableData} />
    </div>
  );
}


// create table of processes
function ProcessTable({ processData }) {
  return (
    <div>
      <h2>Process Information</h2>
      <table border="1" cellPadding="10">
        <thead>
          <tr>
            <th>Process</th>
            {processData.map((process) => (
              <td key={process.name}>{process.name}</td>
            ))}
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>Process Length (ms)</th>
            {processData.map((process) => (
              <td key={process.name}>{process.length}</td>
            ))}
          </tr>
        </tbody>
      </table>
    </div>
  );
}


// allow user to set length of time quantum (for round robin)
function TimeSliceLength() {
  const [numberInput, setNumberInput] = useState(''); // initial value is empty

  // handle changes in the input field
  function handleInputChange(event) {
    const value = parseInt(event.target.value, 10); // convert user input into an integer
    if (!isNaN(value) && value >= 1 && value <= 100) { // only update numberInput if the user entered a valid input
      setNumberInput(value);
    } else if (event.target.value === '') { // allow empty input if user clears input
      setNumberInput('');
    }
  }

  return (
    <form>
      <input
        type="text"
        placeholder="Enter number..."
        value={numberInput}
        onChange={handleInputChange}
      />
      <p> Time Slice Length (ms): {numberInput}</p>
    </form>
  );
}


// FIFO algorithm
function FirstInFirstOut({ processData }) {
  const [barData, setBarData] = useState([]); // initial values are empty

  // generate dataset for stacked bar chart
  useEffect(() => {
    const chartData = processData.map((process) => ({
      label: 'Process ' + process.name,
      data: [process.length],
      backgroundColor: getColor(process.name),
      barThickness: 30,
    }));
    setBarData(chartData);
  }, [processData]); // re-run whenever processData changes

  // options for the stacked bar chart
  const options = {
    responsive: true,
    maintainAspectRatio: false, // allows chart to be resized freely
    indexAxis: 'y', // makes the chart horizontal
    plugins: {
      legend: { position: 'top' },
      tooltip: { enabled: true },
    },
    scales: {
      x: {
        beginAtZero: true, // start x-axis from 0
        stacked: true, // enable stacking on the x-axis (horizontal axis)
        title: {
          display: true,
          text: 'Time (ms)',
        },
      },
      y: { stacked: true }, // enable stacking on the y-axis (verical axis)
    },
  };

  return (
    <div style={{ width: '75%', height: '150px' }}>
      <h2>FIFO Algorithm</h2>
      <Bar data={{ labels: ['FIFO'], datasets: barData }} options={options} />
    </div>
  );
}


// SJF algorithm
function ShortestJobFirst({ processData }) {
  const [barData, setBarData] = useState([]); // initial values are empty

  useEffect(() => {
    // sort processes from shortest to longest
    const sortedData = [...processData].sort((a, b) => a.length - b.length);
    // generate dataset for stacked bar chart
    const chartData = sortedData.map((process) => ({
      label: 'Process ' + process.name,
      data: [process.length],
      backgroundColor: getColor(process.name),
      barThickness: 30,
    }));
    setBarData(chartData);
  }, [processData]); // re-run whenever processData changes

  // options for stacked bar chart
  const options = {
    responsive: true,
    maintainAspectRatio: false, // allows chart to be resized freely
    indexAxis: 'y', // makes the chart horizontal
    plugins: {
      legend: { position: 'top' },
      tooltip: { enabled: true },
    },
    scales: {
      x: {
        beginAtZero: true, // start x-axis form 0
        stacked: true, // enable stacking on the x-axis (horizontal axis)
        title: {
          display: true,
          text: 'Time (ms)',
        },
      },
      y: { stacked: true }, // enable stacking on the y-axis (vertical axis)
    },
  };

  return (
    <div style={{ width: '75%', height: '150px' }}>
      <h2>SJF Algorithm</h2>
      <Bar data={{ labels: ['SJF'], datasets: barData }} options={options} />
    </div>
  );
}


// STCF algorithm
function ShortestTimeToCompletion({ processData }) {
  const [barData, setBarData] = useState([]); // initial values are empty

  useEffect(() => {

    const processList = [...processData];
    let currentList = [];
    let STCFList = [];

    // processes are still being received
    for (let i = 0; i < processList.length; i++){
      currentList.push({name: processList[i]['name'], length: processList[i]['length']}); // receive next process
      currentList.sort((a, b) => a.length - b.length); // sort list from shortest to longest process
      STCFList.push({name: currentList[0]['name'], length: 50}); // simulate running shortest process for 50ms
      currentList[0]['length'] = currentList[0]['length'] - 50; // subtract 50ms from shortest process
    };
    // all processes have been received
    currentList.sort((a, b) => a.length - b.length);
    for (let i = 0; i < processList.length; i++){
      STCFList.push({name: currentList[i]['name'], length: currentList[i]['length']});
    };
    
    // generate dataset for stacked bar chart
    const chartData = STCFList.map((process) => ({
      label: 'Process ' + process.name,
      data: [process.length],
      backgroundColor: getColor(process.name),
      barThickness: 30,
    }));
    setBarData(chartData);
  }, [processData]); // re-run whenever processData changes

  // options for stacked bar chart
  const options = {
    responsive: true,
    maintainAspectRatio: false, // allows chart to be resized freely
    indexAxis: 'y', // makes the chart horizontal
    plugins: {
      legend: { position: 'top' },
      tooltip: { enabled: true },
    },
    scales: {
      x: {
        beginAtZero: true, // start x-axis form 0
        stacked: true, // enable stacking on the x-axis (horizontal axis)
        title: {
          display: true,
          text: 'Time (ms)',
        },
      },
      y: { stacked: true }, // enable stacking on the y-axis (vertical axis)
    },
  };
  
  return (
    <div style={{ width: '75%', height: '150px' }}>
      <h2>STCF Algorithm</h2>
      <Bar data={{ labels: ['STCF'], datasets: barData }} options={options} />
    </div>
  );
}


// helper function to return color based on process name
function getColor(name) {
  const colors = {
    A: 'pink',
    B: 'salmon',
    C: 'sandybrown',
    D: 'palegoldenrod',
    E: 'lightgreen',
    F: 'mediumseagreen',
    G: 'turquoise',
    H: 'royalblue',
    I: 'rebeccapurple',
  };
  return colors[name] || 'gray';
}

export default function MyApp() {
  return (
    <div>
      <h1>Welcome to the Scheduling Algorithm Simulator</h1>
      <h4>Enter Number of Processes (1-9):</h4>
      <NumberOfProcesses />
      <br />
      <h4>Enter Time Quantum for Round Robin (1ms-100ms):</h4>
      <TimeSliceLength />
    </div>
  );
}
